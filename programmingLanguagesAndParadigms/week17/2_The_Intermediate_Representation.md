# The Intermediate Representation 
* The intermediate representation is used to: 
	* Facilitate retargeting by different backends
	* Enable machine-independent code optimisations and code generation strategies.
* Thus the internal representation needs to be:
	* Easy to generate
	* Easy to manipulate
	* Have a low level of abstraction
* There can also be multiple types of intermediate representation:
	* Representations to represent the code
	* Representations to capture properties of the code that are useful for analysis
* Thus intermediate representations can either be graphical or linear depending.

## Abstract Syntax Trees 
![[Pasted image 20230521025752.png]]
* Are parse trees that exclude non-terminal symbols to remove unnecessary information that was gleaned during parsing.
* Are generated by traversing the tree in #postOrderTraversal and removing the non-terminal symbols.

## Linear Code Representations 
```
t1 = load x
t2 = load y
t3 = t1 >t2
if not (t3) goto L
L: 
t4 = 2 * t2
```
### Three-Address-Code
* Each statement is a single operator and there are at most 3 operands.
* It is compact, makes intermediate values explicit and resembles many machines
### Two-Address-Code
* More compact than 3 address code
### One-Address-Code
* More compact and models well onto machines that use a stack/accumulator.
* It is used to construct bytecode interpreters for Java.

## Auxiliary Graph Representations 
* Used for analysis of the code in optimising it.
### Control Flow Graph
* Models the way that the code transfers control as a result of conditionals or loops.
### Data Dependence Graph
* Encodes the flow of data.
### Call Graph
* Shows dependences between procedures.